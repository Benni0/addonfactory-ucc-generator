<?xml version="1.0"?>

<!-- solutions/common/build/shared_build.xml
     ant build file for Solution's apps
     Splunk, Inc.                       -->

<!--
    This build file provides helper methods that ought to be used as a basis for
    other, application specific build files.

    This build file makes assumptions regarding what files should be included in
    the build and how they are processed. Override the populate_staging_directory
    target if the default file copies are insufficient for your purposes.
-->

<project name="shared_build" default="rebuild">

  <!-- Get the environment -->
  <property environment="env" />

  <!-- Setup a temporary directory -->
  <property name="value.temp.directory" value="${java.io.tmpdir}/${user.name}/${ant.project.name}" />

  <!-- ================================================================
       Information
       ================================================================ -->
  <target name="help" description="Print help and terminate">
    <echo>
 Build ${build.name}
 Usage: to see a list of build targets that designed to be called externally, run: "ant -p"
    </echo>
  </target>

  <!-- ===================================================================
       Common initialization tasks (can only be called internally)
       =================================================================== -->
  <target name="-init">

    <!-- Set global properties
         Make sure to define any properties referenced in a prop file before loading the file!

         Note that a property cannot be redefined.  Once set, it is immutable. -->

    <!-- load build properties -->
    <property file="${basedir}/local.build.properties" />

    <!-- setup standard properties -->
    <property name="common.dir" value="${basedir}/contrib/common" />
    <property name="shared.dir" value="${basedir}/contrib/shared" />

    <!-- get the codeline property from the environment variable if defined, otherwise, we'll get it from the default build properties file -->
    <property environment="env" />
    <condition property="codeline" value="${env.CODELINE}">
       <isset property="env.CODELINE" />
    </condition>

    <!-- load the default build properties, this should be last because we want the environment and local properties to take precedence -->
    <property file="${basedir}/build.properties"/>

    <!-- Try to get the appname -->
    <!-- some apps don't define appname, except them here -->
    <condition property="appname" value="${build.name}">
       <or>
          <equals arg1="${build.name}" arg2="splunk_for_vmware" />
          <equals arg1="${build.name}" arg2="unix" />
       </or>
    </condition>

    <!-- populate the appname with the older names that basically served as the appname -->
    <condition property="appname" value="${package.name}">
       <isset property="package.name" />
    </condition>

    <condition property="appname" value="${name.package}">
       <isset property="name.package" />
    </condition>

    <condition property="appname" value="${package.output.filename}">
       <isset property="package.output.filename" />
    </condition>

    <!-- Stop if we couldn't get a value for appname -->
    <fail unless="appname">The appname attribute is not defined. Define the appname variable in build.properties file and set the value to the name of the app (a.k.a. the main directory name of the app).</fail>

    <!-- set default properties -->
    <property name="package.dir" value="${basedir}/package" />
    <property name="stage.dir" value="${basedir}/stage"/>

    <property name="optimization" value="on"/>
    <property name="args" value=""/>

    <!-- for test library -->
    <echo message="optimization=${optimization}"  level="verbose" />

    <property name="release.filename" value="${appname}.${build.type}"/>
    <property name="final_package" value="${basedir}/${release.filename}" />
    <echo>Appname at -init ${appname}</echo>
    <property name="staged_package.dir" value="${stage.dir}/${appname}" />
    <property name="codeline" value="mainline" />

  </target>

  <!-- ===================================================================
       Try to populate appname or throw a warning if we cannot
       =================================================================== -->
  <target name="define_appname">

     <!-- some app don't define appname, except them here -->
     <condition property="appname" value="${build.name}">
        <or>
           <equals arg1="${build.name}" arg2="splunk_for_vmware" />
           <equals arg1="${build.name}" arg2="unix" />
        </or>
     </condition>

     <!-- populate the appname with the older names that basically served as the appname -->
     <condition property="appname" value="${package.name}">
        <isset property="package.name" />
     </condition>

     <condition property="appname" value="${name.package}">
        <isset property="name.package" />
     </condition>

     <condition property="appname" value="${package.output.filename}">
        <isset property="package.output.filename" />
     </condition>

     <!-- Stop if we couldn't get a value for appname -->
     <fail unless="appname">The appname attribute is not defined. Define the appname variable in build.properties file and set the value to the name of the app (a.k.a. the main directory name of the app).</fail>

  </target>

  <!-- ===================================================================
       Cleans everything^H^H^H^H^H^H^H^H^H^Hnothing
       =================================================================== -->
  <target name="clean" depends="-init" description="Clean out the temporary files">
    <delete file="${final_package}" />
  </target>

  <!-- ===================================================================
       Sets libaries for SSHExec and SCP
       =================================================================== -->
  <target name="ssh_init">
     <taskdef name="scp" classname="org.apache.tools.ant.taskdefs.optional.ssh.Scp">
       <classpath>
         <pathelement location="${common.dir}/build/lib/jsch-0.1.48.jar"/>
         <pathelement location="${common.dir}/build/lib/ant-jsch.jar"/>
       </classpath>
    </taskdef>
    <taskdef name="sshexec" classname="org.apache.tools.ant.taskdefs.optional.ssh.SSHExec">
       <classpath>
         <pathelement location="${common.dir}/build/lib/jsch-0.1.48.jar"/>
         <pathelement location="${common.dir}/build/lib/ant-jsch.jar"/>
       </classpath>
    </taskdef>
  </target>

  <!-- ===================================================================
       Adds ant-contrib
       =================================================================== -->
  <target name="init_ant_contrib">
    <taskdef resource="net/sf/antcontrib/antlib.xml">
      <classpath>
         <pathelement location="${common.dir}/build/lib/ant-contrib-1.0b3.jar"/>
      </classpath>
    </taskdef>
  </target>

  <!-- ===================================================================
       Get build number from the cache (if it exists)
       =================================================================== -->
  <target name="get_build_number_offline" depends="-init,define_appname" if="offline">
    <property file="${basedir}/cached_build_info.properties" />

    <echo>Changeset number for the app is ${build.number}</echo>
    <echo>The build number has been loaded from the cache. This should not be used for release since the build number may be out of date.</echo>
  </target>

    <!-- ===================================================================
     Get the latest changeset number from Perforce and place it in the build.number variable
     =================================================================== -->
  <target name="get_build_number" depends="-init,get_build_number_bamboo" description="Get the latest changeset number from Perforce and place it in the build.number variable">
  </target>
  
   <!-- ===================================================================
     Get the latest commit hash from Git and place it in the build.number variable
     =================================================================== -->
  <target name="get_build_number_git" depends="-init" description="Get the latest commit hash from Git and place it in the build.number variable">

      <!-- Run git to get the hash number -->
      <exec failonerror="true" executable="/usr/bin/git" outputproperty="build.number"> <!-- Fail on error is set to true in order to prevent a bad build number from being included -->
        <arg value="rev-parse"/>
        <arg value="--short"/>
        <arg value="HEAD"/>
      </exec>

      <echo>Changeset number for ${appname} (${codeline}) is ${build.number}</echo>

        <!-- Write out the properties to a cache so that an offline sync can be performed -->
      <propertyfile file="cached_build_info.properties" comment="List properties from the last build, used in case an offline build is performed">
        <entry key="build.number" value="${build.number}"/>
        <entry key="build.date" value="${build.date}"/>
      </propertyfile>

   </target>

  <!-- ===================================================================
   Get the latest build number from Bamboo ENV
   =================================================================== -->
  <target name="get_build_number_bamboo" depends="-init" description="Get the latest build number from Bamboo env">

      <!-- if BUILDNUMBER is not set, set it as 0 -->
      <condition property="build.number" value="0">
        <not>  
          <isset property="env.BUILDNUMBER"/>
        </not>
      </condition>

      <!-- Grab the latest build number from Bamboo -->
      <property name="build.number" value="${env.BUILDNUMBER}" />

      <echo>Changeset number for ${appname} (${codeline}) is ${build.number}</echo>

      <!-- Write out the properties to a cache so that an offline sync can be performed -->
      <propertyfile file="cached_build_info.properties" comment="List properties from the last build, used in case an offline build is performed">
          <entry key="build.number" value="${build.number}"/>
          <entry key="build.date" value="${build.date}"/>
      </propertyfile>

  </target>

  <!-- ==================================================================
       Makes the bin directory executable
       ================================================================== -->
  <target name="change_bin_permissions_conditional" if="dir.exists" depends="define_appname">
       <echo>Changing permissions for ${splunkhome}/etc/apps/${appname}/bin</echo>

       <chmod dir="${splunkhome}/etc/apps/${appname}/bin" perm="755" includes="*"/>
  </target>

  <target name="change_bin_permissions" >
        <!-- Set execute permissions on files in the bin directory -->
        <condition property="dir.exists">
           <available file="${splunkhome}/etc/apps/${appname}/bin" type="dir"/>
        </condition>

        <!-- Change the executable file permissions so that Splunk can run them -->
        <antcall target="change_bin_permissions_conditional"/>
  </target>


  <!-- ==================================================================
       Populate the endline_errors_found property with the number of end-lines errors
       ================================================================== -->
  <target name="get_bad_endlines_count" depends="-init">

        <!-- Get the custom task -->
        <taskdef name="replace_endlines" classpath="${common.dir}/build/lib" classname="WrongEndlineReplacementTask" />

        <!-- Replace end-lines with ones matching OS where packaging takes place and populate the property if bad end-lines were found -->
        <replace_endlines outputproperty="endline_errors_found">
            <fileset defaultexcludes="true" dir="${package.dir}">
                <include name="**/*.html" />
                <include name="**/*.conf" />
                <include name="**/*.js" />
            </fileset>
        </replace_endlines>
  </target>

  <!-- ==================================================================
       Validate searchbnf.conf and commands.conf
       ================================================================== -->
  <target name="get_searchbnf_errors" depends="populate_staging_directory">

    <!-- Get the custom task -->
    <taskdef name="validate_searchbnf" classpath="${common.dir}/build/lib" classname="SplunkValidateSearchbnfTask" />

    <validate_searchbnf outputproperty="searchbnf_errors_count">
        <dirset defaultexcludes="true" dir="${stage.dir}">
          <include name="**/TA-*/**/default" />
          <include name="**/DA-*/**/default" />
          <include name="**/SA-*/**/default" />
          <include name="**/Splunk_TA_windows/**/default" />
          <include name="**/SplunkPCIComplianceSuite/**/default" />
          <include name="**/SplunkEnterpriseSecuritySuite/**/default" />
      </dirset>
    </validate_searchbnf>

  </target>

  <!-- ==================================================================
     Define common tasks and dirsets/filesets.
     ================================================================== -->
  <target name="define_shared_variables">

    <taskdef name="validate_dirset" classpath="${common.dir}/build/lib" classname="SplunkDirsetValidationTasks"/>

    <dirset id="all_seccomp_apps" defaultexcludes="false" dir="${stage.dir}">
      <include name="**/TA-*/" />
      <include name="**/DA-*/" />
      <include name="**/SA-*/" />
      <include name="**/Splunk_SA_CIM/" />
      <include name="**/Splunk_TA_nix/" />
      <include name="**/Splunk_TA_windows/" />
      <include name="**/SplunkPCIComplianceSuite/" />
      <include name="**/SplunkEnterpriseSecuritySuite/" />
      <exclude name="**/SA-Eventgen/" />
      <exclude name="**/deployment-apps/" />
      <exclude name="**/test/" />
      <exclude name="**/install/" />
    </dirset>

  </target>

  <!-- ==================================================================
     Validation actions.
     DEPRECATED per SOLNESS-6700
     ================================================================== -->
  <target name="run_validation_tasks">
  
    <echo>This task has been deprecated.</echo>
  </target>

  <!-- ==================================================================
     Generate an error if bad paths exist that will fail on search-head pooled environments (SOLNESS-3099)
     DEPRECATED per SOLNESS-6674/SOLNESS-6675
     ================================================================== -->
  <target name="check_shp_paths">
    <echo>This task has been deprecated.</echo>
  </target>

  <!-- ==================================================================
     Populate the shp_inputs_errors_found property with the number of inputs that are incompatible with search head pooling
     DEPRECATED per SOLNESS-6674/SOLNESS-6675
     ================================================================== -->
  <target name="check_shp_inputs">
    <echo>This task has been deprecated.</echo>
  </target>

  <!-- ==================================================================
       Generate an error for invalid macros (SOLNPCI-601)
       DEPRECATED per SOLNESS-6700
       ================================================================== -->
  <target name="check_macros">
    <echo>This task has been deprecated.</echo>
  </target>

  <!-- ==================================================================
       Generate an error if bad end-lines exist (SOLNESS-546)
       DEPRECATED per SOLNESS-6761
       ================================================================== -->
  <target name="check_endlines">
    <echo>This task has been deprecated.</echo>
  </target>

  <!-- ==================================================================
       Generate an error if errors exist in searchbnf.conf or commands.conf (SOLNPCI-566)
       DEPRECATED per SOLNESS-6728
       ================================================================== -->
  <target name="check_searchbnf">
    <echo>This task has been deprecated.</echo>
  </target>

  <!-- ==================================================================
       Populate the staging directory with the JS and CSS (potentially minified)
       ================================================================== -->
  <target name="populate_staging_directory_css_js" depends="-init,get_build_number_git,init_ant_contrib">
    
    <!-- Deploy the CSS and JS (and optionally optimize it) -->
    <if>
        <or>
            <equals arg1="${value.build.optimize}" arg2="true" />
            <equals arg1="${value.build.optimize}" arg2="1" />
        </or>
        <then>
            <!-- The mapper to map the original source files to the minified versions with the same name, but different path -->
            <mapper id="to_export_dir_mapper" type="glob" from="*" to="${staged_package.dir}/*" />
            
            <!-- Minify the Javascript files -->        
            <apply executable="java" parallel="false">
                
                <!-- Source of the files -->    
                <fileset dir="${package.dir}">
                    <include name="appserver/static/js/**/*.js" />
                    <include name="appserver/static/css/**/*.css" />
                </fileset>
                <arg line="-jar" />
                <arg path="${common.dir}/build/lib/yuicompressor-2.4.7.jar" />
                <srcfile />
                <arg line="-o"/>
                <mapper refid="to_export_dir_mapper" />
                <targetfile />
            </apply>
        </then>
        <else>
            <!-- Copy the unoptimized files over -->
            <copy todir="${staged_package.dir}">
                <fileset dir="${package.dir}">
                    <include name="**/*.js" />
                    <include name="**/*.css" />
                </fileset>
            </copy>
        </else>
    </if>
  </target>
    
  <!-- ==================================================================
       Populate the staging directory with the app code
       ================================================================== -->
  <target name="populate_staging_directory" depends="-init,get_build_number_git">
    <echo>${staged_package.dir}</echo>
    <!-- Create the staging directory -->
    <mkdir dir="${stage.dir}" />

    <!-- Populate the staging directory -->
    <copy todir="${staged_package.dir}">
        <fileset dir="${package.dir}">
            <!-- Skip the files we are going to do token replacements on -->
            <exclude name="default/app.conf" />
            <exclude name="README*" />
        </fileset>
    </copy>

    <!-- Copy in the licenses -->
    <copy file="${common.dir}/misc/license-eula.txt" todir="${staged_package.dir}"/>
    <copy file="${common.dir}/misc/license-eula.rtf" todir="${staged_package.dir}"/>

    <!-- Set up the filter for token replacements -->
    <filterset id="standard_token_replacements" begintoken="$${" endtoken="}">
        <filtersfile file="${basedir}/build.properties" />
        <filter token="version.build" value="${build.number}" />
        <filter token="build.date" value="${build.date}" />
    </filterset>

    <filterset id="standard_token_replacements_legacy" begintoken="@" endtoken="@">
        <filtersfile file="${basedir}/build.properties" />
        <filter token="version.build" value="${build.number}" />
        <filter token="build.date" value="${build.date}" />
    </filterset>

    <!-- Do token replacement on the necessary files -->
    <copy file="${package.dir}/default/app.conf" toFile="${staged_package.dir}/default/app.conf">
        <filterset refid="standard_token_replacements"/>
        <filterset refid="standard_token_replacements_legacy"/>
    </copy>

    <copy todir="${staged_package.dir}">
        <fileset file ="${package.dir}/README*"/>
        <filterset refid="standard_token_replacements"/>
        <filterset refid="standard_token_replacements_legacy"/>
    </copy>

    <!-- Convert the line endings to Unix compatible versions -->
    <antcall target="fix_staging_crlf" />

  </target>

  <!-- ==================================================================
       Populate the splunk_home_defined if splunkhome has been defined
       ================================================================== -->
  <target name="check_splunkhome_path_defined">
    <condition property="splunk_home_defined">
        <isset property="splunkhome" />
    </condition>

    <!-- Don't try to sync if Splunk home is not defined -->
    <fail unless="splunk_home_defined">Splunk home is not defined. Define the Splunk home variable in the local.build.properties file.</fail>

  </target>

  <!-- ==================================================================
       Synchronize the package directory with a Splunk instance but do not bother trying to get the build number from Perforce
       ================================================================== -->
  <target name="offline_sync" description="Synchronize the app code with an install of Splunk but do not assume you have an network connection to Perforce">

    <!-- Set a property noting that we are not going to be able to connect to Perforce and that the cached build info ought to be used -->
    <property name="offline" value="offline" />

    <!-- Call the sync target -->
    <antcall target="sync" />

  </target>

  <!-- ==================================================================
       Synchronize the package directory with a Splunk instance
       ================================================================== -->
  <target name="sync" depends="-init,define_appname,check_splunkhome_path_defined,check_endlines,populate_staging_directory" description="Synchronize the app code with an install of Splunk">

        <!-- Populate the Splunk home directory -->
        <copy todir="${splunkhome}/etc/apps" overwrite="true">
            <fileset dir="${stage.dir}" />
        </copy>

        <!-- Set execute permissions on files in the bin directory -->
        <condition property="dir.exists">
              <available file="${splunkhome}/etc/apps/${appname}/bin" type="dir"/>
        </condition>

        <!-- Change the executable file permissions so that Splunk can run them -->
        <antcall target="change_bin_permissions"/>

        <!-- Purge the temporary directory -->
        <delete dir="${stage.dir}" />

  </target>

  <!-- ==================================================================
       Synchronize the package directory with a Splunk instance and reload the Splunk end-points
       ================================================================== -->
  <target name="sync_reload" depends="-init,check_splunkhome_path_defined,check_endlines,populate_staging_directory,sync" description="Synchronize the app code with an install of Splunk">

        <!-- Call the reload target -->
        <antcall target="splunk_reload" />

  </target>

  <!-- ==================================================================
       Determine if the user has defined a path that they want the output package to go to
       ================================================================== -->
  <target name="check_output_path_defined">
         <condition property="output_path_defined">
            <isset property="package.output.directory"/>
         </condition>
        <echo level="warning">The check_output_path_defined target doesn't do anything. You should test the package.output.directory property directly instead.</echo>
  </target>

  <!-- ==================================================================
       Move the file to the output location if the user has defined one
       Don't call this target, it's called from build.
       ================================================================== -->
  <target name="move_file_to_output" if="package.output.directory">
        <move file="${final_package}" todir="${package.output.directory}"/>
  </target>

  <!-- ==================================================================
       SCP a dir to the target host
       ================================================================== -->
  <target name="scp_dir" depends="ssh_init">
        <scp todir="${remoteuser}@${remotehost}:${remotedir}" keyfile="${sshkey}" verbose="true">
            <fileset dir="${scpdir}" />
        </scp>
  </target>

  <!-- ==================================================================
       SCP a file to the target host
       ================================================================== -->
  <target name="scp_file" depends="ssh_init">
        <scp todir="${remoteuser}@${remotehost}:${remotedir}" keyfile="${sshkey}">
            <fileset dir="${scpdir}">
                <include name="${scpfile}"/>
            </fileset>
        </scp>
  </target>

  <!-- ==================================================================
       ssh_cmd - Runs a remote command on a remote host
       ================================================================== -->
  <target name="ssh_cmd" depends="ssh_init">
        <sshexec host="${remotehost}" username="${remoteuser}" keyfile="${sshkey}" command="${remotecmd}"/>
  </target>

  <!-- ==================================================================
       ssh_script - Runs a local script on a remote host (script is a local script containing terminal commands)
       ================================================================== -->
  <target name="ssh_script" depends="ssh_init">
        <sshexec host="${remotehost}" username="${remoteuser}" keyfile="${sshkey}" commandResource="${remotescript}"/>
  </target>

  <!-- ==================================================================
       replace_property will take an input string and replace values based on the regex passed in as replace_match.
           replace_inboundproperty = property used to load a string from
           replace_outboundproperty = the new property name to write to, will override.
           replace_match = Regex match, example:"[sp]"
           replace_target = what you want to replace the string with
       ================================================================== -->
  <target name="replace_property" depends="init_ant_contrib">
        <echo message="Replacing ${replace_inboundproperty} that contains ${replace_match} with ${replace_target} and storing in a property named: ${replace_outboundproperty}" />
        <propertyregex input="${replace_inboundproperty}" property="${replace_outboundproperty}" regexp="${replace_match}" replace="${replace_target}" global="true" override="true"/>
  </target>
  <!-- ==================================================================
       clear_staging will remove the staging directory for the current build directory
       ================================================================== -->
  <target name="clear_staging" depends="-init">
    <!-- Purge the temporary directory -->
    <delete dir="${stage.dir}" />
  </target>
  <!-- ==================================================================
       Package an installable archive for the app but do not bother trying to get the build number from Perforce
       ================================================================== -->
  <target name="offline_build" description="Create the package for the app but do not assume you have an network connection to Perforce">

    <!-- Set a property noting that we are not going to be able to connect to Perforce and that the cached build info ought to be used -->
    <property name="offline" value="offline" />

    <!-- Call the sync target -->
    <antcall target="build" />

  </target>

  <!-- ==================================================================
       Package an installable archive for the app
       ================================================================== -->
  <target name="build" depends="-init,define_appname,check_endlines,populate_staging_directory,init_ant_contrib" description="Create the package for the app">
    <echo message="Building ${build.name}..." />

    <!-- Determine if the tests should be included -->
    <if>
       <or>
           <equals arg1="${value.build.include_tests}" arg2="true" />
           <equals arg1="${value.build.include_tests}" arg2="1" />
       </or>
       <then>
           <property name="include_tests">1</property>
       </then>
    </if>
    
    <!-- Tar up the results -->
    <tar destfile="${appname}.tar" compression="none">

        <!-- Copy the files in the bin directory with execute permission -->
        <tarfileset dir="${staged_package.dir}" defaultexcludes="true" prefix="${appname}" filemode="755" >
            <include name="**/*.sh" />
            <include name="**/*.exe" />
            <include name="**/*.py" />
            <include name="**/*.bat" />
            <include name="**/*.pl" />
            <include name="**/*.pm" />
            <include name="bin/*" />
        </tarfileset>

        <!-- Copy the rest of the files -->
        <tarfileset dir="${staged_package.dir}" prefix="${appname}">

            <!-- Exclude the executable files we already copied -->
            <exclude name="**/*.sh" />
            <exclude name="**/*.exe" />
            <exclude name="**/*.py" />
            <exclude name="**/*.bat" />
            <exclude name="**/*.pl" />
            <exclude name="**/*.pm" />
            <exclude name="bin/*" />
            
            <!-- Exclude the tests (conditionally) -->
            <exclude name="**/tests/" unless="include_tests" />
            <exclude name="**/tests/*.js" unless="include_tests" />
            <exclude name="default/data/ui/views/test_*.xml" unless="include_tests" />
            <exclude name="appserver/static/tests.js" unless="include_tests" />
        </tarfileset>
    </tar>

    <!-- Compress the archive -->
    <gzip destfile="${final_package}" src="${appname}.tar"/>

    <!-- Delete the intermediate archive -->
    <delete file="${appname}.tar" />

    <!-- Purge the temporary directory -->
    <delete dir="${stage.dir}" />

    <!-- Move the file to the output directory if the user defined one -->
    <antcall target="move_file_to_output" />

  </target>

  <!-- ===================================================================
       A complete rebuild (does not get updated build information from Perforce)
       =================================================================== -->
  <target name="offline_rebuild" depends="clean, offline_build" description="Clean and then build" />

  <!-- ===================================================================
       A complete rebuild
       =================================================================== -->
  <target name="rebuild" depends="clean, build" description="Clean and then build" />

  <!-- ===================================================================
       Restart Splunk
       =================================================================== -->
  <target name="splunk_restart" depends="-init,check_splunkhome_path_defined" description="Restart Splunk">

    <!-- Tell Splunk to restart -->
    <exec failonerror="true" executable="${splunkhome}/bin/splunk"> <!-- Fail on error is set to true -->
        <arg value="restart"/>
        <arg value="--accept-license"/>
    </exec>

  </target>

  <!-- ===================================================================
       Start Splunk
       =================================================================== -->
  <target name="splunk_start" depends="-init,check_splunkhome_path_defined" description="Start Splunk">

    <!-- Tell Splunk to start -->
    <exec failonerror="true" executable="${splunkhome}/bin/splunk"> <!-- Fail on error is set to true -->
        <arg value="start"/>
        <arg value="--accept-license"/>
    </exec>

  </target>

  <!-- ===================================================================
       Restart SplunkWeb
       =================================================================== -->
  <target name="splunk_restart_web" depends="-init,check_splunkhome_path_defined" description="Restart Splunk Web">

    <!-- Tell Splunk to restart -->
    <exec failonerror="true" executable="${splunkhome}/bin/splunk"> <!-- Fail on error is set to true, we want to know if this fails -->
        <arg value="restart"/>
        <arg value="splunkweb"/>
        <arg value="--accept-license"/>
    </exec>

  </target>

  <!-- ===================================================================
       Stop Splunk
       =================================================================== -->
  <target name="splunk_stop" depends="-init,check_splunkhome_path_defined" description="Stop Splunk">

    <!-- Tell Splunk to stop -->
    <exec failonerror="false" executable="${splunkhome}/bin/splunk">
        <arg value="stop"/>
    </exec>

  </target>

  <!-- ===================================================================
       Sync and Restart Splunk
       =================================================================== -->
  <target name="splunk_sync_restart" depends="offline_sync,splunk_restart" description="Sync and Restart Splunk">

  </target>

  <!-- ===================================================================
       Clean Splunk
       =================================================================== -->
  <target name="splunk_clean" depends="-init,check_splunkhome_path_defined,splunk_stop" description="Clean Splunk (be careful!!)">

    <!-- Ask the user if they really want to do this
    <input message="About to do a Splunk clean, sure you want to continue (y/n)?" validargs="y,n" addproperty="do_clean">
        <handler type="greedy" />
    </input>

    <condition property="do_abort">
      <equals arg1="n" arg2="${do_delete}"/>
    </condition>

    <fail if="do_abort">Clean aborted by user.</fail>
    -->

    <echo message="Cleaning Splunk..." />

    <!-- Tell Splunk to clean all-->
    <exec failonerror="true" executable="${splunkhome}/bin/splunk"> <!-- Fail on error is set to true -->
        <arg value="clean"/>
        <arg value="all"/>
        <arg value="-f"/>
    </exec>
  </target>

  <!-- ===================================================================
       Clean App
       =================================================================== -->
  <target name="splunk_clean_app" depends="-init,check_splunkhome_path_defined">
    <!--
    This target performs an app specific clean.

    This should be overridden by apps the need a specific clean operation to occur when Splunk's indexes
    are cleaned (like removing lookups that contain search results).
    -->
  </target>

  <!-- ===================================================================
       Reload Splunk
       =================================================================== -->
  <target name="splunk_reload" depends="-init,check_splunkhome_path_defined" description="Reload Splunk views">

    <!-- Define the username and password if not already defined -->
    <property name="splunk_username" value="admin"/>
    <property name="splunk_password" value="changeme"/>

    <!-- Define a macro that can be used for refreshing Splunk endpoints -->
    <macrodef name="reload_conf">
        <attribute name="endpoint"/>
        <sequential>
            <exec failonerror="true" executable="${splunkhome}/bin/splunk"> <!-- Fail on error is set to true -->
                <arg value="_internal"/>
                <arg value="call"/>
                <arg value="/admin/@{endpoint}/_reload"/>
                <arg value="-auth"/>
                <arg value="${splunk_username}:${splunk_password}"/>
                <arg value="--accept-license"/>
            </exec>
        </sequential>
    </macrodef>

    <!-- Tell Splunk to reload its configs -->
    <reload_conf endpoint="views" />
    <reload_conf endpoint="savedsearch" />
    <reload_conf endpoint="script" />
    <reload_conf endpoint="workflow-actions" />
    <reload_conf endpoint="macros" />

    <!-- Below are other endpoints that we may want to refresh (ignored for now since this makes the reload take longer)
    <reload_conf endpoint="transforms-lookup" />
    <reload_conf endpoint="transforms-extract" />
    <reload_conf endpoint="monitor" />
    <reload_conf endpoint="localapps" />
    <reload_conf endpoint="commandsconf" />
    -->

  </target>

  <!-- ===================================================================
       Configure SplunkWeb for easier web development
       =================================================================== -->
  <target name="splunkweb_conf" description="Configure SplunkWeb for easier web development">
    <mkdir dir="${splunkhome}/etc/system/local/"/>

    <echo file="${splunkhome}/etc/system/local/web.conf">[settings]
    enable_gzip=True
    minify_js=False
    minify_css=False
    js_no_cache=True
    </echo>
  </target>

  <!-- ===================================================================
       Configure SplunkWeb to use a custom root endpoint
       =================================================================== -->
  <target name="splunkweb_customendpoint" description="Configure SplunkWeb to use a custom root endpoint">
    <mkdir dir="${splunkhome}/etc/system/local/"/>

    <echo file="${splunkhome}/etc/system/local/web.conf">[settings]
    root_endpoint=/splunk_es
    enableSplunkWebSSL = false
    </echo>
  </target>

  <!-- ==================================================================
       Populate the splunk_exe_exists if the Splunk executable exists in the defined Splunk home path
       ================================================================== -->
    <target name="check_splunk_exe_exists">
        <available file="${splunkhome}/bin/splunk" property="splunk_exe_exists" />
    </target>

  <!-- ==================================================================
       Stops Splunk if it appears to be installed
       ================================================================== -->
  <target name="stop_splunk_if_exists" if="splunk_exe_exists">
        <antcall target="splunk_stop" />
  </target>

  <!-- ==================================================================
       Populate the splunk_package_defined if splunkpackage has been defined
       ================================================================== -->
  <target name="check_splunk_package_defined">
        <condition property="splunk_package_defined">
            <isset property="splunkpackage" />
        </condition>

        <!-- Stop if Splunk package is not defined -->
        <fail unless="splunk_package_defined">Splunk package file name is not defined. Define the Splunk package variable in the local.build.properties file.</fail>
  </target>


  <!-- ==================================================================
       Download Splunk from releases.splunk.com
       ================================================================== -->
  <target name="download_splunk" depends="-init" description="Download Splunk from releases.splunk.com">
     <get src="${splunkpackageurl}" dest="${splunkpackage}"/>
  </target>

  <!-- ==================================================================
       Download and install Splunk
       ================================================================== -->
  <target name="download_and_install_splunk" depends="-init,download_splunk,install_splunk" description="Download Splunk from releases.splunk.com and install it" />

  <!-- ==================================================================
       Download Splunk, install it, and install the app
       ================================================================== -->
  <target name="download_and_install_splunk_and_app" depends="-init,download_splunk,install_splunk_and_app" description="Download Splunk from releases.splunk.com and install it along with the app" />

  <!-- ==================================================================
       Deploy a fresh install of Splunk automatically (will delete the existing Splunk installation)
       ================================================================== -->
  <target name="install_splunk" depends="-init,check_splunkhome_path_defined,check_splunk_package_defined,check_splunk_exe_exists,stop_splunk_if_exists" description="Install a fresh install of Splunk (will delete the current install)">

        <!-- Delete the current Splunk directory -->
        <delete dir="${splunkhome}" />

        <!-- Make the temporary directory -->
        <mkdir dir="${value.temp.directory}" />

        <!-- Make sure to remove any artifacts of previous Splunk installs -->
        <delete file="${value.temp.directory}/splunk.tar" />

        <!-- Untar the package -->
        <!-- <untar src="${splunkpackage}" dest="${value.temp.directory}" compression="gzip" /> --><!-- Cannot use this since Ant's tar doesn't carry permissions over -->
        <gunzip src="${splunkpackage}" dest="${value.temp.directory}/splunk.tar" />

        <exec executable="tar" output="/dev/null">
            <arg value="xf" />
            <arg value="${value.temp.directory}/splunk.tar" />
            <arg value="-C" />
            <arg value="${value.temp.directory}" />
        </exec>

        <!-- Make the Splunk install directory -->
        <mkdir dir="${splunkhome}" />

        <!-- Need to make sure we have permission to write so that we can move the files -->
        <!-- Note: I'm not using the chmod task because it fails on the long path names. I'm not calling chmod with exec because I need bash to expand * -->
        <exec executable="bash" dir="${value.temp.directory}/splunk/">
            <arg value="-c"/>
            <arg value="chmod -R u+w *"/>
        </exec>

        <!-- Move the files to the path -->
        <move todir="${splunkhome}">
            <fileset dir="${value.temp.directory}/splunk"/>
        </move>

        <!-- Delete the temporary directory -->
        <delete dir="${value.temp.directory}/splunk" />
        <delete dir="${value.temp.directory}/splunk.tar" />

  </target>

  <!-- ==================================================================
       Deploy a fresh install of Splunk and the app (will delete the existing Splunk installation)
       ================================================================== -->
  <target name="install_splunk_and_app" depends="-init,install_splunk,sync,splunk_start" description="Install Splunk and the app in a fresh installation" />

  <!-- ==================================================================
       Download package from the release server
       ================================================================== -->
  <target name="download_from_release_server" depends="-init,define_appname" unless="offline" description="Download release from build server.">

       <!-- Don't try if we are not setup to get a file from the release server -->
       <fail unless="builds.basedir">This build is not setup to download a package from the release server</fail>
       <fail unless="builds.server.ip">This build is not setup to download a package from the release server</fail>
       <fail unless="builds.server.port">This build is not setup to download a package from the release server</fail>

       <mkdir dir="${value.temp.directory}/${appname}"/>

       <!-- Retrieve the directory listing -->
       <get src="http://${builds.server.ip}:${builds.server.port}/${builds.basedir}" dest="${value.temp.directory}/${appname}/current.txt"/>      <!-- Extract the latest file name from the HTML -->
       <loadfile srcfile="${value.temp.directory}/${appname}/current.txt" property="version_release">
         <filterchain>
           <tokenfilter>
             <filetokenizer/>
             <replaceregex replace="\1" pattern="^.*?([-_a-zA-Z0-9]+-\d\.\d\.\d-\d+\.((spl)|(tgz))).*$" flags="s"/>

           </tokenfilter>
         </filterchain>
       </loadfile>

       <!-- Uncomment for debugging -->
       <!-- <echo>${version_release}</echo> -->

       <!-- Retrieve the actual file -->
       <get src="http://${builds.server.ip}:${builds.server.port}/${builds.basedir}/${version_release}" dest="${value.temp.directory}/${appname}.tar.gz"/>

       <!-- Delete temporary file -->
       <delete file="${value.temp.directory}/${appname}/current.txt"/>

   </target>

    <!-- ==================================================================
         Get and untar the release package
         ================================================================== -->
   <target name="get_and_untar_release_package" depends="-init,define_appname,download_from_release_server">

       <gunzip src="${value.temp.directory}/${appname}.tar.gz" dest="${value.temp.directory}" />
       <untar src="${value.temp.directory}/${appname}.tar" dest="${value.temp.directory}" />

   </target>

   <!-- ==================================================================
        Fix CRLF
        ================================================================== -->
   <target name="fix_staging_crlf" depends="-init,define_appname">

        <!-- Convert the line endings to Unix compatible versions -->
        <fixcrlf defaultexcludes="yes" srcdir="${stage.dir}/${appname}" eol="lf">
            <include name="**/*.conf" />
            <include name="**/*.txt" />
            <include name="**/README.txt" />
        </fixcrlf>

   </target>

   <!-- ==================================================================
        Populate the staging directory with the app code
        ================================================================== -->
   <target name="populate_staging_directory_release" depends="-init,define_appname,get_and_untar_release_package">

        <!-- Create the staging directory -->
        <mkdir dir="${stage.dir}" />
        <echo>${stage.dir}/${appname}</echo>

        <!-- Populate the staging directory -->
        <copy todir="${stage.dir}/${appname}">
            <fileset dir="${value.temp.directory}/${appname}" />
        </copy>

        <!-- Convert the line endings to Unix compatible versions -->
        <antcall target="fix_staging_crlf" />

        <!-- Delete the temporary files -->
        <antcall target="remove_downloaded_release_files" />

   </target>

   <!-- ==================================================================
        Synchronize the released version with a Splunk instance
        ================================================================== -->
   <target name="sync_release" depends="-init,check_splunkhome_path_defined,populate_staging_directory_release" description="Synchronize the released version of the code with an install of Splunk">

        <!-- Populate the Splunk home directory -->
        <copy todir="${splunkhome}/etc/apps" overwrite="true">
            <fileset dir="${stage.dir}" />
        </copy>

        <!-- Change the executable file permissions so that Splunk can run them -->
        <antcall target="change_bin_permissions"/>

        <!-- Delete the temporary files -->
        <antcall target="remove_downloaded_release_files" />

    </target>

    <!-- ==================================================================
         Remove temporary files downloaded from the release server
         ================================================================== -->
    <target name="remove_downloaded_release_files" depends="-init,define_appname">

         <!-- Delete the temporary files -->
         <delete file="${value.temp.directory}/${appname}.tar" />
         <delete dir="${value.temp.directory}/${appname}" />

     </target>


    <!-- ===================================================================
         Make releases by moving files to the build server's bamboo/releases folder
         =================================================================== -->
    <target name="release" depends="build,release-setup,release-scp" if="release.local">
        <echo>MOVE ${release.file} to ${builds.server.ip}:${builds.server.releases}/${builds.basedir}</echo>
        <move file="${release.file}" todir="${builds.server.releases}${file.separator}${builds.basedir}"/>
    </target>

    <target name="release-setup" depends="-init">
        <fail message="This build is not setup to release" unless="builds.basedir"/>
        <fail message="This build is not setup to release" unless="builds.server.ip"/>
        <fail message="This build is not setup to release" unless="builds.server.releases"/>
        <!-- Guess where the output is. It depends on whether it was already moved or not. -->
        <condition property="release.file"
                   value="${package.output.directory}/${release.filename}"
                   else="${final_package}" >
            <isset property="package.output.directory"/>
        </condition>
        <condition property="release.local">
            <and>
                <or>
                    <not><isset property="builds.server.ip"/></not>
                    <contains string="${builds.server.ip}" substring="${host.name}"/>
                </or>
                <not><os family="windows"/></not>
                <available file="${builds.server.releases}" type="dir"/>
            </and>
        </condition>
        <condition property="ssh_key_exists">
            <and>
                <not><isset property="release.local"/></not>
                <available file="${user.home}/.ssh/id_dss"/>
            </and>
        </condition>
        <fail message="The release path doesn't exist">
            <condition>
                <and>
                    <isset property="release.local"/>
                    <not><available file="${builds.server.releases}" type="dir"/></not>
                </and>
            </condition>
        </fail>
        <fail message="Can't ssh without an ssh key">
            <condition>
                <and>
                    <not><isset property="release.local"/></not>
                    <not><isset property="ssh_key_exists"/></not>
                </and>
            </condition>
        </fail>
        <echo>Release ${release.file} to ${builds.server.ip}:${builds.server.releases}/${builds.basedir}</echo>
    </target>

    <target name="release-scp" depends="release-setup" unless="release.local">
        <echo>SCP ${release.file} to ${builds.server.ip}:${builds.server.releases}/${builds.basedir}</echo>
        <scp file="${release.file}" trust="true"
             todir="bamboo@${builds.server.ip}:${builds.server.releases}/${builds.basedir}"
             keyfile="${user.home}/.ssh/id_dss"
             passphrase="build secret" />
    </target>
</project>

