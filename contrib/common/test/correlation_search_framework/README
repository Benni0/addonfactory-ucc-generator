Correlation Search Test Framework

Introduction:

Correlation Searches included wih the Splunk App for Enterprise Security and
Splunk App for PCI compliance often depend on complex conditions spanning
multiple splunk sourcetypes, eventtypes, and time ranges.

While desirable, "black-box" testing of these searches often fails in practice
because of the complexity of the Splunk environment. For a typical Correlation
Search to fire, it is often the case that the entire set of prerequisite
events listed below must succeed without failure, before a Correlation Search
can be executed successfully:

1. Incoming data must be classified by Splunk's eventtyping and sourcetype
   classification.
2. Indexed data must be normalized to the Common Information Model
   via transforms.conf and props.conf stanzas.
3. Summary data/TSIDX namepace data/lookup table data must be generated
   via scheduled searches, postprocess commands, or scripted inputs.

Only after all of the preceding have succeeded can the activities
conducted by the Correlation Search actually be tested:

4. CIM-based event matching (does the search match the
   events we think it does?)
5. Notable event generation (are notable events generated as expected?)

To facilitate testing of Correlation Searches, we have created a framework
that decouples steps 1-3 in the above process from steps 4-5, in an attempt
to make testing less fragile and more modular. This framework is currently 
located in //splunk/solutions/common/test/framework.
 
=======================================
To construct a test, follow these steps. This procedure is meant as a rough
guideline to follow; in general each test may have special requirements
that necessitate more or less work.

 
1. Set up the "minimal test data". The test data will have a different
   format depending on the target. For information on what data
   format each test data class expects, review the testdata.py class.

   There are four classes of interest:
   
   		TsidxTestData - used for prepopulating data in a TSIDX namespace
   		EventTestData - used for prepopulating simple events in a Splunk index
   		TrackerTestData - used for appending data to a lookup table file
   		SummaryTestData - used for prepopulating data to a summary index (to be completed)    		
   		
   	Each class is located in testdata.py and is internally documented,
   	specifying the expected data parameters. In general, each individual 
   	Correlation Search will expect different data; therefore, it is 
   	necessary to examine the Correlation Search closely to determine the
   	minimal set of data required to trigger Notable Event creation. 
   	
   	A second concern is this: how can we be sure that the notable event
   	created by our test is the one we are looking for? To circumvent this
   	issue, the test framework includes the capability to replace any field
   	within the test data with a dynamically-generated UUID (universally unique
   	identifier). This UUID will be used later to locate the Notable Events.

2. Create the test data. If the test data has been created successfully,
   this is as simple as calling:

		testdata.create()
 
3. Set up the Correlation Search object for the Correlation Search being tested.
   This is equivalent to simply calling splunk.saved.dispatchSavedSearch() on the 
   Correlation Search. We have provided some wrapper scripts for managing 
   saved search execution, which could be replaced by more robust methods if necessary.
 
4. Execute the Correlation Search.
 
		job = test.execute()
 
5. Validate that the Notable Events have been generated. This step consists
   of executing a saved search of the following form:
   
   		index=notable <field>=<UUID value>
   		
   which will uniquely identify the Notable Events generated in this test
   execution.

   In the tests we have provided, we simply test for the existence of one
   or more notable events via a simple assertion:
   
   		assert job.count >= 1
   		
   	The use of ">=" versus "==" as the comparator is motivated by the
   	fact that during debugging, it is common practice to run multiple
   	test runs which may overlap while the tests are in a broken state. 

    Also note that the "job" object returned by the test here is a
    true Splunk search job, so the processing can be as minimal as a simple
    count of events returned, or can make more extensive comparisons on 
    field data in the result set. However, be aware that search job artifacts
    may expire prematurely.
  
6. [Optional] Revert any changes made to indexed data if necessary to avoid
   interfering with subsequent tests. In practice we have found this
   to be necessary only while debugging. The use of UUID-based unique
   identifiers for identifying notable events also reduces the probability
   of test failure.
   
=============================================
To execute tests from the command line:

1. Ensure that you have py.test installed on your system.
2. Ensure that Splunk with ES or PCI, as appropriate, is
   installed and running. Since the ES/PCI apps are very tightly
   coupled, with interdependencies between apps, for the moment
   it is recommended to use a full installation for Correlation
   Search testing. In the future this requirement may be relaxed.
3. Ensure that Splunk Python libraries are in your path:

	. $SPLUNK_HOME/bin/setSplunkEnv

3. Execute the tests:

	<path>/<to>/py.test -s -v -v -v --debug --report=skipped test_sa_access_protection_correlation_searches.py
	
=============================================
Example Correlation Search test creation

First, examine the Correlation Search to see what data it is based on. Data could be:

    - Indexed raw events
    - A TSIDX namespace created by "tscollect"
    - A summary index created by "collect"
    - A lookup table file.
    
In each case, we need to construct a "chunk" of raw data that satisfies the
initial conditions of the search and produces the correct Notable Event
as output. If we do this, we will have successfully tested the Correlation
Search syntax for correctness based on known good data.

As an example, consider the following Correlation Search from
DA-ESS-AccessProtection:
    
    [Access - High or Critical Priority Individual Logging into Infected Machine - Rule]
    action.email.sendresults = 0
    action.notable = 1
    alert.digest_mode = 1
    alert.suppress = 1
    alert.suppress.fields = user,dest
    alert.suppress.period = 86300
    alert.track = false
    cron_schedule = */5 * * * *
    disabled = True
    dispatch.earliest_time = -20m@m
    dispatch.latest_time = -5m@m
    dispatch.rt_backfill = 1
    enableSched = 1
    search = (tag=authentication action=success (user_is_privileged="true" OR user_priority="critical" OR user_priority="high") ) OR (tag=malware tag=attack action=allowed)
        | tags outputfield=tag
        | eval group=case(tag=="authentication","authentication",tag=="malware","malware")
        | eval user=if(tag=="malware",null(),user)
        | eval signature=if(tag=="authentication",null(),signature)
        | stats values(user) as user,values(signature) as signature,dc(group) as group_count by dest
        | search group_count>1
    
    
The precondition for this search that must be satisfied before ANY Notable Event
can be created is an OR statement that pulls in two distinct categories of data.
BOTH categories must be present for the Correlation Search to be successful:

1. (tag=malware tag=attack action=allowed)
2  (tag=authentication action=success (user_is_privileged="true" OR user_priority="critical" OR user_priority="high") )

For simplicity, we will focus on #1: (tag=malware tag=attack action=allowed)

In this case, the search looks at raw tagged events. To generate raw events that 
match the conditions later in the search, we first need to make sure that we 
can match the initial event condition. To do this, we need to look at several 
configuration files in the TAs distributed with ES/PCI:

    - eventtypes.conf
    - props.conf
    - tags.conf
    - transforms.conf
    
A simple "grep" on a ES installation in this case shows us an eventtype
we may be able to use. Note: Not all sourcetypes are appropriate for testing
purposes (see "Things that will trip you up," below).  

    $ grep -r "attack" $SPLUNK_HOME/etc/apps | grep malware
    ...
    /opt/splunk/etc/apps/TA-trendmicro/default/eventtypes.conf
    ...

Typically, the "eventtypes.conf" and "tags.conf" files will contain the information
we need. In this case, there is an eventtype in TA-trendmicro which likely corresponds
to the raw events that we want. We can select an eventtype essentially
arbitrarily to proceed:

    [trendmicro_attack]
    search = sourcetype=WinEventLog:Application:trendmicro ("Virus alert" OR "VirusMalware" OR "Virus Detected" OR "Virus/Malware" OR "Grayware/Spyware")
    #tags = malware attack

The corresponding tags.conf configuration file stanza is:

    [eventtype=trendmicro_attack]
    malware = enabled
    attack = enabled

Therefore IF we construct a raw event that matches the search definition in
eventtypes.conf, we should be able to satisfy the initial conditions
of the Correlation Search (however, there may be additional output conditions
that need to be satisfied as well). This definition is:

   sourcetype=WinEventLog:Application:trendmicro ("Virus alert" OR "VirusMalware" OR "Virus Detected" OR "Virus/Malware" OR "Grayware/Spyware")

Now we need to look at the corresponding "props.conf" and "transforms.conf" stanzas
to determine how we can create the event matching these criteria. Usually it is
simplest to work from an existing sample event in the <app_name>/samples directory,
if one exists.

This is a sample full Trendmicro event:

    09/23/10 05:32:56 AM
    LogName=Application
    SourceName=Trend Micro OfficeScan Server
    EventCode=10
    EventType=2
    Type=Warning
    ComputerName=ACMETREND1
    User=SYSTEM
    Sid=S-1-5-18
    SidType=1
    Category=5
    CategoryString=System
    RecordNumber=70930
    Message=Virus alert.
    PE_RAMNIT.H is detected on L-mickey02(SYSTEM) in ACME domain.
    Infected file: C:\Program Files\Dealio Toolbar\IE\4.0.2\dealioToolbarIE.dllDetection date: 9/22/2010 19:22:50
    Action: Virus successfully detected, cannot perform the Clean action (Cannot perform the Quarantine action)

This is a minimal event that will trigger our correlation search:

    Message=Virus alert.
    JS_INJECT.VIB is detected on %s(SYSTEM) in ACME domain.
    Action: Virus successfully detected, cannot perform the Quarantine action

The logic here is as follows; we can follow this by looking at the eventtype
definition as well as the original Correlation Search:

    search = sourcetype=WinEventLog:Application:trendmicro ("Virus alert" OR "VirusMalware" OR "Virus Detected" OR "Virus/Malware" OR "Grayware/Spyware")

    1. The "Virus Alert" text is a precondition of the search
       defined in eventtypes.conf. Thus, we need to retain this value in the raw event.
    2. The %s is a string which will be replaced by our unique identifier for
       the Notable Event. Usually, this is a UUID.
    3. The text in the "Action" field is required to satisfy the 
       "action=allowed" condition in the search. This can be determined by
       looking at the transforms.conf and props.conf files, which contain the
       following stanzas. Follow each stanza "back to the source" to ensure
       that the test data you are creating will be extracted properly.
       
       a. The "action" field is not derived directly from the original data,
          since it is not a key=value pair. Instead, the "vendor_action" field
          becomes the "action" field, as defined in props.conf:
          
            [WinEventLog:Application:trendmicro]
            LOOKUP-action_for_wineventlog_application_trendmicro = trendmicro_action_lookup vendor_action OUTPUTNEW action,app
            
        b. The "trendmicro_action_lookup" is also defined in transforms.conf:
        
	        [trendmicro_action_lookup]
			filename = trendmicro_actions.csv
			
		c. The lookup table "trendmicro_actions.csv" contains the following
		   field conversions:
		   
		    vendor_action,action,app
		   	"Virus successfully detected, cannot perform the Clean action",allowed,
			"Virus successfully detected, cannot perform the Quarantine action",allowed,
			"Cleaned",blocked,
			"logged in",success,trendmicro

        d. The "vendor action" field is extracted based on a stanza in
           transforms.conf:
        
            [vendor_action_for_wineventlog_application_trendmicro]
            REGEX = (?:Action|Result):\s+([^(]+)
            FORMAT = vendor_action::"$1"

        Therefore, to get an "action" value of "allowed", we need to make the
        "vendor_action" field in the input event matches the following string
        after the REGEX in transforms.conf is applied:
        
        	 "Virus successfully detected, cannot perform the Quarantine action"
            
From this point we can begin to construct the actual test. We will utilize the
EventTestData() class defined in

    //splunk/solutions/common/test/correlation_search_framework/testdata.py

Each class in the "testdata.py" file is a subclass of a master "TestData" class,
and represents an independent category of data that might be used to trigger a
Correlation Search. The available classes are:

    EventTestData - corresponding to indexed raw events
    TsidxTestData - corresponding to data in a TSIDX namespace created by "tscollect"
    TrackerTestData - corresponding to an entry in a lookup table file.
    
Categories of data that are NOT defined as of this writing (26sep2012) 
but would be useful include:

    SummaryTestData - corresponding to data in a summary index
    EventgenTestData - corresponding to data generated using SA-Eventgen as
                       the generating mechanism (perhaps by replaying old data)

Each subclass of TestData is responsible for defining its own input format. The
EventTestData class accepts a list of Python tuples consisting of the following
fields:

    (<raw event text>, 
     <count of events to be created>,
     <unique uuid replacement pattern>,
     <sourcetype>)

In this example, we construct a list of 2 events corresponding to the two
categories of data sought by our original correlation search, which looks for an
authentication event on a server that is also infected with malware.

    data = [("""Message=Virus alert.
            JS_INJECT.VIB is detected on %s(SYSTEM) in ACME domain.
            Action: Virus successfully detected, cannot perform the Quarantine action
            """ % TestData.UUID_PATTERN, 1, TestData.UUID_PATTERN, 'WinEventLog:Application:trendmicro'),
            ("%s sshd[25089]: [ID 800047 auth.info] Accepted publickey for mawe from 123.123.123.123 port 54321 ssh2" % TestData.UUID_PATTERN, 1, TestData.UUID_PATTERN, 'syslog')]

The second tuple represents an event that will correspond to the search string
"(tag=authentication action=success (user_is_privileged="true" OR user_priority="critical" OR user_priority="high") )",
which is the other category of data required by the Correlation Search. We have NOT
detailed the logic behind this test data here, but the thought process behind 
it is similar. Once a test event has been generated in this manner, it can 
often be reused to test multiple correlation searches.

We next define a unique_id_field for the Notable Event that we expect to be
created.

    unique_id_field = 'dest'

This field will be assigned a UUID (universally unique identifier) at the time
the event is created. The UUID can then be used to identify the Notable Event
as definitively having been created by the current test execution.

Finally, we create the EventTestData object and run the data generation
routine:

	testdata = EventTestData(data, self._namespace, self._owner, self._key, offset=600)
    uuid = testdata.create()


===========================================
Things that will trip you up


1. Offset Values

The "offset" value (as seen in the above example) is a number of seconds
to be subtracted from the current time. This value is used to modify the
time of the event, in the event that this is necessary to match the timeframe
of the correlation search. In the above example, the "dispatch.latest_time" 
value did not include the current time:

	dispatch.latest_time = -5m@m

Therefore the time of the test events needs to be set to more than 5 minutes
in the past.

2. Timestamp extraction

Note that the test event data in the above example did NOT include a
timestamp itself. The EventTestData class simply prepends a timestamp to the 
generated event. If the sourcetype or eventtype associated with the event
invokes additional timestamp extraction routines, the events you generate
may not have the expected timestamp. For instance, for any sourcetype that
sets DATETIME_CONFIG=CURRENT in props.conf, offset values will simply be
ignored, since that configuration settings forces the event to be indexed
with the current time (See TA-sav for an example of this in action). 