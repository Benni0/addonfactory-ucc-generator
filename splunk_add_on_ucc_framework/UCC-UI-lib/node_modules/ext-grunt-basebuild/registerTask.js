var _ = require("underscore")

function exclude_from_hooks(grunt, excludelist) {
  var array = grunt.config.get('buildinfo.hooks');
  for (var key in array) {
      var hook = grunt.config.get('buildinfo.hooks.' + key);
      for (var index in excludelist) {
           hook = _.filter(hook,function( s ) { 
               return s.indexOf( excludelist[index] ) == -1; 
           });
           grunt.config.set('buildinfo.hooks.' + key, hook);
      }
  }
}

module.exports = function(grunt) {
    'use strict';

    return {
	    pkgname: function() {
            grunt.log.write( grunt.config('buildinfo').name );
        },
        config: [
            ['printconfig']
        ],
        build: function(){
            switch (grunt.config.get('buildinfo.type')) {
                case 'CommonComponent':
                case 'InfraApp':
                    grunt.task.run(['buildTask:clean_before_build',
                    'buildTask:download_dependencies',
                    'buildTask:HOOK_prebuild',
                    'buildTask:copy',
                    'buildTask:HOOK_prebundle',
                    'buildTask:compress',
                    'buildTask:HOOK_postbundle',
                    'buildTask:clean_after_build',
                    'buildTask:HOOK_postbuild'
                    ]);
                    break;
                default:
                    grunt.task.run(['buildTask:clean_before_build',
                    'buildTask:download_dependencies',
                    'buildTask:HOOK_prebuild',
                    'buildTask:copy',
                    'buildTask:update_license',
                    'buildTask:concat',
                    'buildTask:patternReplace',
                    'buildTask:HOOK_prebundle',
                    'buildTask:remove_sample',
                    'buildTask:compress',
                    'buildTask:HOOK_postbundle',
                    'buildTask:clean_after_build',
                    'buildTask:HOOK_postbuild'
                    ]);
                    break;
            };
        },
        offlinebuild: function() {
           var excludelist = ['babel','uglify'];
           exclude_from_hooks(grunt,excludelist);

           grunt.task.run(['buildTask:clean_before_build',
                'buildTask:HOOK_prebuild',
                'buildTask:copy',
                'buildTask:update_license',
                'buildTask:concat',
                'buildTask:patternReplace',
                'buildTask:HOOK_prebundle',
                'buildTask:compress',
                'buildTask:HOOK_postbundle',
                'buildTask:clean_after_build',
                'buildTask:HOOK_postbuild'
            ]);
        },
	    deploy_local_app: [
	        ['buildTask:clean_before_build',
             'buildTask:download_dependencies',
             'buildTask:HOOK_prebuild',
             'buildTask:copy',
             'buildTask:update_license',
             'buildTask:concat',
             'buildTask:patternReplace',
             'buildTask:HOOK_prebundle',
             'rsync:dist',
             'buildTask:clean_after_build'
	        ]
    	],
        run_jasmine_tests: [
            ['shell:run_jasmine_tests']
        ],
        generate_docs: [
            ['buildTask:generate_docs']
        ],
        create_sample_app: [
            ['generate_docs', 'buildTask:download_dependencies', 'buildTask:generate_app']
        ],
        create_and_package_sample_app: [
            ['create_sample_app', 'buildTask:compress_app']
        ],
        package_sample_app: [
            ['buildTask:compress_app']
        ],
        publish: function(){
            switch (grunt.config.get('buildinfo.type')) {
                case 'InfraApp':
                    grunt.task.run(['buildTask:HOOK_prepublish',
                    'buildTask:publish'
                    ]);
                    break;
                default:
                    grunt.task.run(['buildTask:generate_docs',
                    'buildTask:HOOK_prepublish',
                    'buildTask:publish'
                    ]);
                    break;
            };
        },
        publish_app: [
            ['buildTask:publish_app']
        ],
        default: [
            ['build']
        ],
        js_check : [
            ['eslint']
        ],
        py_check : [
            ['flake8']
        ],
        deploy_to_splunk: function() {
            var etcapps = grunt.option('splunk_home') || grunt.config('buildinfo').splunk_home || '/opt/splunk';
            if (etcapps.endsWith("/")) {
                etcapps += "etc/apps/";
            } else {
                etcapps += "/etc/apps/";
            }

            grunt.log.writeln("Syncing with ", etcapps)

            var options = {
                cmd: "rsync",
                args: ["-azcui", "./stage/", etcapps]
            }
            var done = this.async()
            grunt.util.spawn(options, function(error, result, code) {
                if (error) {
		    grunt.log.error("Looks like you don't have a valid \'splunk_home\' path specified in Gruntfile.js/local.properties.json; define it and try again");
                    return grunt.fail.fatal(error);
                }
                grunt.log.writeln(result)
                done();
            });
        }
    };

};
