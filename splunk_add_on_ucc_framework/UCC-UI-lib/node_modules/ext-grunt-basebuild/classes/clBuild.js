/*jslint node: true */
'use strict';

var grunt = require('grunt');
var utils = require("../common/utils.js");
var fs = require('fs');
var path = require('path');

var ARTIFACTS_CONF_NAME = 'artifacts.conf'

function createArtifactsConfSync(artifactory) {
  if (!artifactory.url || !artifactory.branchpath) {
    throw new Error('url and branchpath have to be defined in package.json');
  }

  var content = "[artifactory]\n";
  content += 'url=' + artifactory.url + '\n';
  content += 'branchpath=' + artifactory.branchpath + '\n';
  if (artifactory.maxcount) {
    content += 'maxcount=' + artifactory.maxcount + '\n';
  }

  if (artifactory.searchdir) {
    content += 'searchdir=' + artifactory.searchdir + '\n';
  }

  content += '\n';

  if (artifactory.dep) {
    //eslint-disable-next-line
    for (var artifact in artifactory.dep) {
      content += '[dep:' + artifact + ']\n';
      if (artifactory.dep[artifact].path) {
        content += 'path=' + artifactory.dep[artifact].path + '\n';
      }
      if (artifactory.dep[artifact].uncompress) {
        content += 'uncompress=' + artifactory.dep[artifact].uncompress + '\n\n';
      }
    }
  }

  if (artifactory.dep_paths) {
    content += '[dep_paths]\n';
    if (artifactory.dep_paths.contrib_path) {
      content += 'contrib_path=' + artifactory.dep_paths.contrib_path + '\n';
    }

    if (artifactory.dep_paths.local_path) {
      content += 'local_path=' + artifactory.dep_paths.local_path + '\n';
    }
  }

  fs.writeFileSync(ARTIFACTS_CONF_NAME, content, 'utf8');
}

/*---------------------------------------------------*/
function Build() {
    this.name = grunt.config.get('buildinfo.name');
}

Build.prototype.prebuild = function(grunt) {

    var hooks = grunt.config.get('buildinfo.hooks');
    if (hooks && ('prebuild' in hooks)) {
        grunt.task.run(hooks.prebuild);
    } else {
        console.info('Prebuild HOOK not configured');
        return true;
    }
}

Build.prototype.clean_before_build = function(grunt) {
    return grunt.task.run('clean:before_build');
}

Build.prototype.download_dependencies = function(grunt) {

    var installPath = path.join(__dirname, '..', '..', '..');

    if (grunt.file.exists(installPath + "/node_modules/ext-grunt-basebuild/basebuild_requirements.txt")) {
        grunt.task.run('shell:base_pypi_pull');
    }

    if (grunt.file.exists(installPath + '/bower.json')) {
        grunt.task.run('shell:bower_install');
    }

    var pkg_info = grunt.config.get('package');
    var artifactory = pkg_info.artifactory;
    try {
      if (artifactory) {
        createArtifactsConfSync(artifactory);
      }
    } catch (e) {
      console.warn(e)
    } finally {
      if (grunt.file.exists(installPath + '/artifacts.conf')) {
        var refresh_deps = utils.isenabled(grunt, 'refresh_deps');
        grunt.task.run('shell:artifactory_pull:' + refresh_deps);
      }
    }
}

Build.prototype.copy = function(grunt) {

    grunt.task.run('copy:source');

    if (Object.keys(grunt.config.get('chmod')).length > 0) {
        grunt.task.run('chmod');
    }
}

Build.prototype.update_license = function(grunt) {
    grunt.task.run('copy:update_license');
}

Build.prototype.concat = function(grunt) {
    if (grunt.config.get('concat')) {

        // Set correct access permissions
        var confarray = [];
        var concatconfig = grunt.config.get('concat');
        for (var key in concatconfig) {
            var poweraccess = grunt.config.get('buildinfo.poweraccess') || false;
            if (grunt.config.get('buildinfo.name') == key) {
                if (poweraccess == false) {
                    confarray.push('concat:' + key);
                }
            } else {
                confarray.push('concat:' + key);
            }
        };
        if (confarray.length > 0) {
            grunt.task.run(confarray);
        }
    }
}

Build.prototype.patternReplace = function(grunt) {
    grunt.task.run("patternReplace");
}

Build.prototype.prebundle = function(grunt) {

    var hooks = grunt.config.get('buildinfo.hooks');
    if (hooks && ('prebundle' in hooks)) {
        grunt.task.run(hooks.prebundle);
    } else {
        console.info('Prebundle HOOK not configured');
        return true;
    }
}

Build.prototype.remove_sample = function(grunt) {
    if (grunt.option('withsample')) {
        console.info('Will not remove sample for this build');
    } else {
        grunt.task.run("shell:remove_sample");
    }
}

Build.prototype.compress = function(grunt) {
    if (grunt.config.get('buildinfo.extension') == null) {
        grunt.config.set('buildinfo.extension', 'tgz');
    }
    grunt.task.run("compress:package");
}

Build.prototype.postbundle = function(grunt) {

    var hooks = grunt.config.get('buildinfo.hooks');
    if (hooks && ('postbundle' in hooks)) {
        grunt.task.run(hooks.postbundle);
    } else {
        console.info('Postbundle HOOK not configured');
        return true;
    }
}

Build.prototype.clean_after_build = function(grunt) {

    grunt.task.run('clean:after_build');

}

Build.prototype.prepublish = function(grunt) {

    var hooks = grunt.config.get('buildinfo.hooks');
    if (hooks && ('prepublish' in hooks)) {
        grunt.task.run(hooks.prepublish);
    } else {
        console.info('Prepublish HOOK not configured');
        return true;
    }
}

Build.prototype.publish = function(grunt) {
  var artifactsPath = grunt.option('artifactspath')
                     || grunt.config.get('artifactspath')
                     || grunt.config.get('buildinfo.artifactspath') || '.';
  var repoPath = grunt.option('repopath')
                || grunt.config.get('repopath')
                || grunt.config.get('buildinfo.repopath') || '';
  console.log('ConfigPath : ' + artifactsPath);
  console.log('RepoPath : ' + repoPath);
  grunt.task.run("shell:artifactory_push:" + artifactsPath + ":" + repoPath);
}

Build.prototype.postbuild = function(grunt) {

    var hooks = grunt.config.get('buildinfo.hooks');
    if (hooks && ('postbuild' in hooks)) {
        grunt.task.run(hooks.postbuild);
    } else {
        console.info('Postbuild HOOK not configured');
        return true;
    }
}

Build.prototype.deploy = function(grunt) {
    if((grunt.config.get('buildinfo.splunk_home') || grunt.option('splunk_home')) &&
       (grunt.config.get('buildinfo.remotehost') || (grunt.option('remotehost')))){
        grunt.task.run("rsync:dist");
    }
    else{
        grunt.task.run("deploy_to_splunk");
    }
}

Build.prototype.generate_docs = function(grunt) { return true; }

/*----------------------------------------------------*/

function AppSuiteBuild() {
    Build.call(this);
}

AppSuiteBuild.prototype = Object.create(Build.prototype);
AppSuiteBuild.prototype.constructor = AppSuiteBuild;

AppSuiteBuild.prototype.update_license = function(grunt) {
    grunt.task.run('copy:update_license_appsuite');
}

AppSuiteBuild.prototype.compress = function(grunt) {
    grunt.task.run('compress:package_app_suite');
}

/*----------------------------------------------------*/

function InfraAppBuild(){
    Build.call(this);
}

InfraAppBuild.prototype = Object.create(Build.prototype);
InfraAppBuild.prototype.constructor = InfraAppBuild;

InfraAppBuild.prototype.concat = function(grunt) {
    return true;
}

InfraAppBuild.prototype.update_license = function(grunt) {
    return true;
}

InfraAppBuild.prototype.copy = function(grunt) {
    grunt.task.run('shell:copy');
}

InfraAppBuild.prototype.patternReplace = function(grunt) {
    return true;
}

/*----------------------------------------------------*/

function CommonComponentBuild() {
    Build.call(this);
    function find_type(types) {
        for (var i = 0; i < types.length; i++) {
            if (grunt.config.get('buildinfo.name').indexOf(types[i]) === 0) {
                return types[i];
            }
        }
        return 'generic';
    }

    this.appType = find_type(['ui', 'api', 'lib']);
    switch(this.appType) {
        case 'ui':
            grunt.config.set('buildinfo.extension', 'tgz');
            break;
        case 'api':
            grunt.config.set('buildinfo.extension', 'tar');
            break;
        case 'lib':
            if(fs.existsSync('bower.json') || fs.existsSync('package.json')){  //Python modules will be packaged differently
                grunt.config.set('buildinfo.extension', 'tgz');
            }   
    }
}

CommonComponentBuild.prototype = Object.create(Build.prototype);
CommonComponentBuild.prototype.constructor = CommonComponentBuild;

CommonComponentBuild.prototype.clean_before_build = function(grunt) {
    return grunt.task.run('clean:before_build');
}

CommonComponentBuild.prototype.concat = function(grunt) {
    return true;
}

CommonComponentBuild.prototype.update_license = function(grunt) {
    return true;
}

CommonComponentBuild.prototype.copy = function(grunt) {
    grunt.task.run("copy:commoncomponent_" + this.appType);
     
    if(grunt.config.get('copy').source != undefined){ // Incase there are app specific files to be copied
        grunt.task.run("copy:source");
    }
}

CommonComponentBuild.prototype.patternReplace = function(grunt) {
    return true;
}

CommonComponentBuild.prototype.compress = function(grunt) {
    grunt.task.run("compress:sharedpkg_" + this.appType);
}

CommonComponentBuild.prototype.publish = function(grunt) {
    if (fs.existsSync('bower.json')) {
        grunt.task.run("http:compare_version_in_bower");
    }

    if (fs.existsSync('package.json')) {
        grunt.task.run("shell:npm_publish");
    }
}

CommonComponentBuild.prototype.publish_app = function(grunt) {
    if (this.appType === 'ui') {
        var name = grunt.config.process('<%=buildinfo.name%>');
        grunt.config.set('buildinfo.name', 'app-'+name);
        grunt.task.run("shell:artifactory_push");
    }
}

CommonComponentBuild.prototype.clean_after_build = function(grunt) {
    return true;
}

CommonComponentBuild.prototype.generate_docs = function(grunt) {
    if (this.appType === 'ui') {
        grunt.task.run(['jsdoc']);
    }
}
CommonComponentBuild.prototype.generate_app = function(grunt) {
    switch(this.appType) {
        case 'ui':
            grunt.task.run("mkdir");

            var name = grunt.config.process('<%=buildinfo.name%>');
            var filename = 'stage/app-' + name + '/default/app.conf';
            var lines = ['[ui]', 'is_visible = 1', 'label = ' + name];
            grunt.file.write(filename, lines.join('\n'));

            grunt.task.run(['shell:pypi_pull', 'shell:pypi_pull_cleanup', 'copy:sample_app_files', 'shell:pypi_create_package']);
            break;
        case 'api':
            grunt.task.run(['shell:pypi_pull', 'shell:pypi_pull_dev', 'shell:pypi_pull_cleanup', 'copy:commoncomponent_api', 'compress:sharedpkg_api']);
            break;
    }
}

CommonComponentBuild.prototype.compress_app = function(grunt) {
    switch(this.appType) {
        case 'ui':
            grunt.task.run(['compress:package_sample_app']);
            break;
    }
}
/*------------------------------------------------------*/

exports.Build = Build;
exports.CommonComponentBuild = CommonComponentBuild;
exports.AppSuiteBuild = AppSuiteBuild;
exports.InfraAppBuild = InfraAppBuild;
